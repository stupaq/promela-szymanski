\input{./short-report-include.tex}

\usepackage{multirow}
\usepackage{pifont}
\newcommand{\ok}{\ding{51}}
\newcommand{\xx}{\ding{55}}

\newcommand{\eventually}{\, \operatorname{\lozenge} \,}
\newcommand{\always}{\, \operatorname{\square} \,}
\newcommand{\until}{\, \operatorname{\mathcal{U}} \,}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeheader{Analysis of Szymanski's algorithm in Spin}{Mateusz Machalica}

\subsection*{Evaluated properties}

During the course of this brief analysis of Szymanski's mutual exclusion algorithm we will repeatedly refer to the following properties:
\begin{enumerate}
    \item\label{mutual_exclusion}
        $\always \forall_i \forall_j (i = j \lor \neg \verb+P[i]@critical_section+ \lor \neg \verb+P[j]@critical_section+)$
    \item\label{inevitable_anteroom}
        $\neg (\exists_i \eventually (\verb+P[i]@request_entry+ \until (\neg (\verb+we[i] && !chce[i]+) \until \verb+P[i]@critical_section+)))$
    \item\label{anteroom_exit}
        $\always \forall_i (\exists_j (\verb+we[i] && !chce[i]+ \implies i \neq j \land \verb+wy[j]+))$
    \item\label{liveness}
        $\always \forall_i (\verb+P[i]@request_entry+ \implies \eventually \verb+P[i]@critical_section+)$
    \item\label{linear_wait}
        linear wait % TODO
    \item\label{anteroom_exit2}
        $\always \forall_i (\exists_j (\verb+P[i]@in_anteroom+ \implies i \neq j \land \verb+wy[j]+))$
\end{enumerate}
, where we quantify over the set of process identifiers and constructs of the form $\verb+P[i]@label+$ mean that process $i$ is about to execute instruction labelled with \verb+label+.
Names of the labels should be understood intuitively and match names of the labels present in provided models.
Note that pairs of operators $\forall$ and $\always$ as well as $\exists$ and $\eventually$ are commutative, therefore all properties have the expected invariant form $\always (\ldots)$.

Please note that property (\ref{anteroom_exit}) no longer reflects our intentions when we start permuting assignment statements in the protocol's epilogue as described in the next section.
For this reason we have proposed more accurate (based on process' instruction pointer) definition of the state described as a \emph{waiting room} in Szymanski's original paper \cite{Original}.
Improved definition is being used in the LTL formulation of property (\ref{anteroom_exit2}).

All experiments were conducted with \emph{weak fairness} enabled.
Even though for some properties this assumption can be weakened, it is crucial for proving liveness since in the real-world algorithm we implement each wait statement as a loop, that means all processes are executable at all times.

\subsection*{Summary of the results}

% TODO
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{4}{*}{properties}     & \multicolumn{9}{|c|}{models} \\
                                & \multicolumn{7}{|c|}{failure susceptible} & \multicolumn{2}{|c|}{failure resistant} \\
                                & never blocking & \multicolumn{6}{|c|}{blocking in local section} & never blocking & blocking in local section \\
                                & 321 & 321 & 312 & 231 & 213 & 132 & 123 &  &  \\
\hline
(\ref{mutual_exclusion})        & \ok & \ok & \ok & \xx & \xx & \xx & \xx &  &  \\
\hline
(\ref{inevitable_anteroom})     & \xx & \xx & \xx & \xx & \xx & \xx & \xx &  &  \\
\hline
(\ref{anteroom_exit})           & \ok & \xx & \xx & \xx & \xx & \xx & \xx &  &  \\
\hline
(\ref{liveness})                & \ok & \xx & \ok & \xx & \xx & \xx & \xx &  &  \\
\hline
(\ref{linear_wait})             & \ok & \ok & \ok & \xx & \xx & \xx & \xx &  &  \\
\hline
(\ref{anteroom_exit2})          & \ok & \xx & \ok & \xx & \xx & \ok & \ok &  &  \\
\hline
\end{tabular}
\end{center}

I strongly believe that most of the labels in above summary are self-explanatory.
The only model's feature which might be a bit cryptic is the permutation associated with it.
If we associate the following labels with assignment statements present in protocol's epilogue:
\begin{enumerate}
    \item $\verb+chce[i] = false;+$
    \item $\verb+we[i] = false;+$
    \item $\verb+wy[i] = false;+$
\end{enumerate}
, then the permutation denotes the order of execution of above statements in the epilogue.
Labels ,,never blocking'' and ,,blocking in local section'' refer to the ability of each process to block infinitely in its local section.

\subsection*{Results discussion}

It should be now clear why property (\ref{anteroom_exit2}) is more on par with our intentions -- every permutation of epilogue's assignments that falsifies $\verb+chce[i]+$ before $\verb+we[i]+$, \emph{tricks us} into thinking that process $i$ is in waiting room, while it is actually leaving critical section.
This is also an explanation why (\ref{anteroom_exit}) does not hold for assignments permutation ,,312'' in ,,never blocking'' model, while (\ref{anteroom_exit2}) does.

There exists as very simple counterexample which explains why properties (\ref{anteroom_exit}), (\ref{liveness}) and (\ref{anteroom_exit2}) does not hold for ,,blocking in local section'' model with assignments permutation ,,321''.
If process $\alpha$ proceeds through prologue, critical section and halts between assignment ,,2'' and ,,1'', then the other process $\beta$ can enter the waiting room and wait for any (other) process $k$ to set $\verb+wy[k]+$ to true, which might never happen, since process $\alpha$ can get stuck in local section after setting $\verb+chce[i]+$ to false in the last instruction of the epilogue.

Even simpler counterexample exists for property (\ref{inevitable_anteroom}) which states that every process must visit waiting room before entering critical section in every turn of the main loop.
It is easy to verify that if processes enter and leave critical section one after another, without contention, then none of them enters waiting room.

% TODO

\subsection*{Final remarks}

Failure susceptible version of the algorithm is not precisely formulated in \cite{Original}.
As a result of our analysis, we have determine which permutation of epilogue's assignment statements leads to the algorithm that ensures mutual exclusion, liveness and linear wait time, even in the model where processes can block in their local sections.

% TODO

\begin{thebibliography}{9}
  \bibitem{Original} B. K. Szymanski \\
    \newblock ,,A simple solution to Lamport's concurrent programming problem with linear wait''
\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
% vim: noet:sw=2:ts=2:tw=160
